# CH10 必須システムサービス

## 10.1 システムクロックの設定

### システムクロックとハードウェアクロック
- ハードウェアクロック
    - ハードウェアとして内蔵された時計
    - 電源がオフでも動く（コンピュータ内の電池で動いてる）
- システムクロック
    - Linuxのカーネル内に存在する時計
    - Linux起動時にハードウェアクロックを参照して設定される→その後は独立して動く
- `date`コマンドはシステムクロックを参照して日付を表示する
    - 書式：`date [MMDDhhmm[[CC]YY][.ss]]`
        - CC: 西暦の上2桁
        - YY: 西暦の下2桁
        - ss: 秒
    - 引数を＋で始めると、表示の書式を操作できる

```
└─(11:07:46)──> date                                                                                                                                                                        ──(Sun,Feb05)─┘
Sun Feb  5 11:07:54 JST 2023
┌─(~)──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────(ubuntu@lts:pts/0)─┐
└─(11:07:54)──> date "+%Y"                                                                                                                                                                  ──(Sun,Feb05)─┘
2023
┌─(~)──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────(ubuntu@lts:pts/0)─┐
└─(11:08:06)──> date "+%Y/%m"                                                                                                                                                               ──(Sun,Feb05)─┘
2023/02
```

- `hwclock`：dateで設定したシステムクロックをハードウェアクロックに設定する
    - ハードウェアクロックを表示したり、システム→ハードに設定、ハード→システムに設定したりできる
- `timedatectl`：systemdを採用してる場合に使えるやつ

### NTPによる時刻設定
- Network Time protocol：ネットワーク経由でクロックを同期するプロトコル
- 正確な時間を設定するには、NTPサーバから情報を取得する
    - `ntpdate`：NTPサーバから現在時刻を取得する
- NTPサーバを自前で運用できる
    - 組織内にNTPクライアントが多い場合におすすめ
    - 起動例：`systemctl start ntpd.service`
    - `ntpq`：NTPサーバの状態を照会できる
    - `/etc/ntp.conf`でサーバの設定を行う

### Chrony
- NTPサーバ・クライアントソフトウェア
- デーモン`chronyd`とクライアント`chronyc`で構成される
- `/etc/chrony.conf`が設定ファイル
- ntpとchronyの両方を同時に使うことはできない

## 10.2 システムログの設定
- log: コンピュータの動作状況の記録
- syslog
    - 様々なイベントのログの入出力を管理するソフトウェア
        - 他にはrsyslog, syslog-ngなどがある
    - 他プログラムからのメッセージを受け取り、出力元や優先度に応じて分類し、指定された出力先に送る

### rsyslogの設定
- `/etc/rsyslog.conf`および/etc/rsyslog.dディレクトリ以下で行う
- 設定ファイルの書式：`ファシリティ.プライオリティ  出力先`
    - ファシリティ：メッセージの生成もと（具体的にはカーネルや実行中のプロセス）
    - プライオリティ：メッセージの重要度（低く設定するほど、ログ情報量が多くなる）
        - 「.」で指定→指定したプライオリティ以上を出力
        - 「=」で指定→指定したもののみ出力
    - 出力先：ログファイルやユーザの端末、他ホストなどを選択できる
- /etc/rsyslog.confの設定例
    - `kern.* -/var/log/kern.log`：カーネルのログを対象ファイルに出力（-は書き込みを同期しないという意味→システムクラッシュ時に保存されない可能性はある）
    - `*.*;authpriv.none /var/log/messages`：認証情報以外を全てファイルに保存する
- `logger`コマンド：ログメッセージの生成
    - 書式：`logger [-p facility.priority] [-t tag] messages`
- `systemd-cat`コマンド：コマンド実行結果をジャーナルに書き込める
    - 書式：`systemd-cat <command>`
### ログ調査
- システムの利用状況やソフトウェアの動作に異常がないかどうかを確認、また問題の兆候を発見できることもある
    - 主要なログファイルは`/var/log/messages`(Debian GNU/Linux Ubuntuでは`/var/log/syslog`)
- `who`：ログイン中のユーザを調べる
    - `w`：システム情報も加えて表示できる
        - これらは/var/run/utmpを参照している
- `last`：最近ログインしたユーザの一覧を表示できる
    - /var/log/wtmpを参照する
- `lastlog`：/var/log/lastlogファイルを参照し、ユーザごとに最近のログイン一覧を表示する
- `journalctl`：systemdのログを閲覧できる
    - ex. sshd.service関連のログのみ表示：`journalctl -u ssh.service`
    - 保存先：/var/log/journalや/var/run/log/journal内にあるバイナリ（/runはメモリ上の仮想的なファイルシステム→再起動すると消える）
### ログファイルのローテーション
- 膨大していくログを切り分けて、整理できる機能のこと
- `logrotate`ユーティリティがローテーション機能を提供する
    - cronで定期実行する
    - 設定ファイルは`/etc/logrotate.conf`

ex. Ubuntu22.04
```bash
cat /etc/logrotate.conf                                                                                                                                               
# see "man logrotate" for details

# global options do not affect preceding include directives

# rotate log files weekly
weekly

# use the adm group by default, since this is the owning group
# of /var/log/syslog.
su root adm

# keep 4 weeks worth of backlogs
rotate 4

# create new (empty) log files after rotating old ones
create

# use date as a suffix of the rotated file
#dateext

# uncomment this if you want your log files compressed
#compress

# packages drop log rotation information into this directory
include /etc/logrotate.d

# system-specific logs may also be configured here.
```

## 10.3 メール管理
### メール配送の仕組み
- 電子メールを取り扱うソフトウェア
    - MTA(message transfer agent
        - メールの配送に使われる
        - SMTPプロトコルでメッセージのやり取りをするため、SMTPサーバと呼ばれる
            - 代表的なSMTPサーバ：sendmail, Postfix, exim
    - MDA(mail delivery agent
        - ローカル配送プログラム
    - MUA(mail user agent
        - メールクライアントソフトウェア
- 作成されたメールが相手に届くまでの流れ
    - 差出人側
        - MUAで作ったメールが、送信ようMTA①に送られる
        - MTA①は、メールアドレスから配送先メールサーバを調べ、メールをMTA②へ送る
            - 配送先メールサーバを尋ねる先は、相手ドメインのDNSサーバ
            - 脱線)MXレコード(mail excahnger record)
                - DNSで定義されるドメイン情報の一つ
                - 特定のドメイン宛ての電子メールをどのメールサーバーに転送すればいいか指定するレコード
                - メールサーバのホスト名（FQDN)を指定
        - MTA②がメールを受け取ると、MDAがメールの宛先となっているユーザのメールボックスにメールを格納する
    - 受取人側
        - POPサーバやIMAPサーバを経由して、自分のメールボックスからメールを取り出す

### MTAの起動
システムごとに異なるが、25番ポートを開いているソフトウェアを調べると動いてるMTAがわかる
- コマンド例：`netstat -atnp | grep 25`（コマンド詳細は11.3.1にて）

### メールの送信と確認
- `mail`コマンド
    - コマンドラインでメールを送信したり、受信メールを確認できる
    - 書式：`mail [-s subject] [mail address | user name]`
        - ユーザ名のみを指定すると、ローカルシステムのユーザ宛にメールを送る

実際に使ってみた例
```bash
sudo apt install mailutils
...

mail -s "test mail" narutyan0711@gmail.com
Cc:
test
<ctrl + d>
```

<img width="572" alt="Screenshot 2023-02-07 at 21 46 13" src="https://user-images.githubusercontent.com/27912121/217248689-8dbb82fb-5c75-45e4-98d5-fa3cd19b9832.png">

Gmailサーバのフィルタで弾かれると思ったが、大丈夫だった。同じIPから来たら通るようになってるのかな？👀

### メールの転送とエイリアス
ある宛先に届いたメールを、別のメールアドレスで受け取る方法
- `/etc/aliases`でエイリアスを設定する方法
    - ex. root宛のメールをadminとlpicで受け取れるようにする(rootには届かなくなる
```
root: admin, lpic
```
    - `newaliases`: 設定内容を有効化する
- 各ユーザのホームディレクトリに`.forward`ファイルを用意する方法
    - ファイルに転送先のメールアドレスを記述する
    - 一時的にメールを転送したい場合などに便利
※重要：上記二つのエイリアス設定方法と`newaliases`コマンドの必要な理由を理解すべし

- メールキュー
    - 送信待ちのメールが蓄えられるところ
        - 定期的に再送信が試みられ、規定回数内に送信できない場合は送信者に通知する
    - 蓄えられる理由
        - 送信先メールサーバが停止している
        - 宛先がDNSで検索できなかった
    - `mailq`で内容を表示できる　

## 10.4 プリンタ管理
### 印刷の仕組み
- CUPS(Common Unix Printing System)：多くのLinuxディストリビューションで採用されている印刷サブシステム
    - 主な特徴
        - IPP(Internet Printer Protocol)の採用
            - インターネット経由での印刷ができる（リモートプリント）
                - [Epsonの記事](https://www.epsonconnect.com/iguide/ja/iPrint_remote.htm)
        - PPD(PostScript Printer Description)ファイルのサポート
            - AdobeのPPD形式のファイル（テキストファイル）でデバイスドライバの設定ができる
                - プリンタの機種依存情報を記述するところ
                - PPDファイルは/etc/cups/ppd以下に格納する
            - [Canonの記事](https://faq.canon.jp/app/answers/detail/a_id/17844/~/%E3%80%90pixel%E3%80%91ppd%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%A8%E3%81%AF)
        - Webブラウザで設定できる
            - 631番ポートに接続すると、Webインターフェースが表示される
        - プリンタクラス（複数プリンタを一台のプリンタに見せかける機能）をサポート
    - 設定ファイル
        - `/etc/cups/cupsd.conf`
            - 印刷要求をネットワーク経由で受け付ける場合のポート番号や、接続するクライアントのアクセス許可を設定する
        - `/etc/cups/printers.conf`
            - プリンタに関する情報などを設定する
    - サービスの起動
        - SysVinit→`/etc/init.d/cups start`
        - systemd→`systemctl start cups.service`

- CUPSを使った印刷処理の流れ
    - ①アプリケーションや印刷コマンドから印刷データを受け取る
        - プリンタの設定オプションはPPDファイルから受け取る
    - ②スプーラが印刷データを受け付け、スケジューリングを行う
    - ③プリンタが受け付けられない形式のデータを、一旦中間形式としてPDFまたはPostScriptにフィルタで変換する
    - ④PPDに定義されたフィルタにより、最終の印刷データに変換する
    - ⑤処理した印刷データをCUPSのバックエンドに送る
    - ⑥バックエンドは印刷データをローカル接続(ex. USB)またはネットワーク経由(ex. IPP, LPR)でプリンタに渡す
        - LPR(Line PRinter daemon protocol)：TCP/IPベースのプリンタプロトコル

### 印刷関連コマンド
- `lpr`：プリントキューにファイルや標準入力を送る
    - `lpr -#5 /etc/passwd`
    - `cat ~/.ssh/<secret key name> | lpr`（これはやめよう
- `lpq`：プリントキューの内容を表示する
- `lprm`：プリントキューにある印刷要求を削除する

※重要：各印刷処理コマンドを理解すべし

※注意：各コマンドはBSD LPR印刷システムと互換性がある。
対して、System V印刷システムと互換性を持つコマンド群(`lp`, `lpstat`, `cancel`)もあり、CUPSではこちらが標準。

