# ファイルとプロセスの管理

## 基本的なファイル管理
- 圧縮：gzip, bzip, xz
- 解凍：-dオプション
- 圧縮ファイルの閲覧：zcat, bzcat, xzcat
- アーカイブ(複数のファイルをまとめたファイル)の作成、展開
    - `tar`：アーカイブ作成(圧縮も可)、内容確認、展開
    - `cpio`：ファイルをアーカイブにコピーしたり、アーカイブからファイルをコピーする
    - `dd`：入力側に指定したファイルからの入力を、ファイルもしくは標準出力に送る
        - ex. /dev/sdbに接続されたディスクの内容を/dev/sdcに出力する(*パーティション情報やファイルシステムごとディスクをコピーできる)
            - `dd if=/dev/sdb of=/dev/sdc`

## パーミッションの設定
- 所有者：ファイルやディレクトリを作成したユーザ
- アクセス権：どのユーザに対してどういった操作を許可するのかという情報
    - 所有者、所有グループに属するユーザ、その他ユーザのさん種類に対して設定可能
    - r, w, xの三種
- `chmod`：アクセス権の変更
    - オプションの例
    - `go+w`：グループ、その他に書き込み権限を与える
    - `o-rw`：その他から読み取り、書き込み権を剥奪する
- SUID, SGID
    - SUID
        - `passwd`コマンドを使い、一般ユーザは自身のパスワード変更ができる
        - パスワードの変更は`/etc/passwd`ファイルに保存される
            - `/etc/passwd`ファイルのアクセス権は `-rw-r-r-- 1 root root...`
                - rootユーザのみ書き込みできる
            - `passwd`コマンドの権限は`-rws--x--x 1 root bin...`
                - 実行権`s`：実行権を持っているユーザによってプログラムが実行された場合、ファイルの所有者の権限で実行されることを意味→これを`SUID`という
                - 指定したファイルにSUIDを設定する例：`chmod u+s samplefile`
    - SGID：グループ版のSUID
        - ディレクトリに設定すると、そのディレクトリ内で誰がファイルを作成しようとも、ファイルの所有グループは同じになる
            - 複数ユーザで共有するディレクトリに設定すると管理しやすくなる
- スティッキービット「`t`」
    - ディレクトリ内のファイルを保護するアクセス権ビット
    - ディレクトリに設定されている場合、ファイルを削除できるのはその所有者、ディレクトリの所有者、または特権を持つユーザーだけに制限される
- デフォルトのアクセス権
    - ファイルは666から、ディレクトリは777からunmask値を引いた値
    - unmask値はユーザごとに設定され、`unmask`コマンドで値を確認できる

## ファイルの所有者管理
- 所有者の変更(`chown`)
    - rootユーザのみ可能
- グループの変更(`chgrp`)
    - 一般ユーザも使用可能(変更可能範囲は、デフォルトのアクセス権となるは実行するユーザが所属するグループのみ)
    - 複数ユーザで協働作業をする場合、各ユーザが属する1つのグループ(グループA)を作成し、ディレクトリに対して所有グループをグループAに設定しておくと便利
        - グループAに属するユーザはファイルに自由にアクセスでき、その他のユーザはアクセスできないといった設定ができる

## ハードリンクとシンボリックリンク
異なった名前で同一のファイルにアクセスできる仕組み。Linuxの場合は二種類の仕組みがある。
- ハードリンク
    - Linuxでは、ファイルをディスクに保存すると、重複しないiノード番号が割り当てられる。
        - iノードはファイルシステムごとに管理されているため、異なるファイルシステム上にハードリンクを作成することは不可。
        - ディレクトリに対しても作成できない。
    - 全てのファイルには対応するiノードが存在し、iノードにはディスク上のファイルに関する属性情報が格納されている。
        - 属性情報の一部：ファイル種別、ファイルサイズ、アクセス権、所有者、リンク、ディスク上の物理的な保存場所（ブロック番号）。
    - ディレクトリは、所属するファイル名とiノードを関連づけている。
    - ファイルの実体（ディスク上のデータ）が一つでも、それを参照するファイルが複数あれば、それぞれのファイル名で同一の実態を参照できる。これがハードリンク。
        - 元ファイルとリンクとして作成したファイルの区別がつけられない。どちらもiノードが同じだから。
        - ハードリンクが複数ある場合、その全てを削除するまで実態は削除されない。
```bash
$ ls -li
<ノード番号> <パーミッション> <リンク数> <所有者> <グループ> <ファイルサイズ> <最終更新日時>
```

- シンボリックリンク
    - リンク元の場所を指し示すポインタ。
    - ディレクトリに対しても作成可能。
    - 異なるファイルシステム間でも作成可能。
    - シンボリックリンクを残したままリンク元のファイルを削除可能。
    - アクセス権表示は`lrwxrwxrwx`となるが、実際はリンク元ファイルのアクセス権と同じになる。
    - winのショートカット、macのエイリアスはシンボリックリンクに相当する。
    - リンクの作成(`ln`)
        - オプションなし→ハードリンク　`-s`オプション→シンボリックリンク
    - リンクのコピー
        - `cp`でシンボリックリンクをコピーすると、リンク元のファイルの内容がコピーされる
            - `-d`オプションでリンク自体をコピーできる

## プロセスの管理
### プロセス：OSが管理するメモリ上の(実行されている/実行できる状態になっている)プログラムの基本単位
- 実行中に他のプロセスを起動するものもある（元プロセスを親プロセス、起動された方を子プロセス）
- 開始時にPID(識別子)が割り当てられる
    - Linuxではシステム起動時後、まずinitプログラムが実行される→initのPIDは常に1
- プロセスは開始したユーザから引き継がれたUIDとGIDを持ち、この値でプロセスがシステムのどの部分にアクセスできるかを制御する
    - プロセスは、プロセスを実行したユーザ権限で動作することになる
### プロセスの終了
- `kill`：プロセスに対してシグナル（プロセスへ送られるメッセージ）を送信する
    - デフォルトでは`TERM`シグナル（正常終了）が送られる
    - TERMシグナルで終了できない場合は`KILL`シグナル（強制終了）を送る
        - ※ファイル破損やシステム障害につながるので最終手段である
- `pgrep`：指定した名前のプロセスに対応するPIDを表示する
- `killall`, `pkill`：PIDでなくプロセス名で指定できるkillコマンド
### ジョブ管理
- ジョブ：ユーザがコマンドやプログラムをシェル上で実行するひとまとまりの処理単位
    - シェル上で実行した一つのコマンド、複数コマンドをパイプしたもの、どちらも一つのジョブになる
- フォアグラウンドジョブは全てのキーボード入力を受ける→このジョブが終了するまでシェル上で他の作業ができない
- バックグラウンドジョブに処理時間のかかるジョブを割り当てると、処理中にシェル上で操作ができる
    - コマンドラインの最後に`&`をつけることでバックグラウンド実行できる
    - `nohup`：ログアウト後もプログラムを実行させられる
        - Ex. `# nohup updatedb &`
- フォアグラウンドとバックグラウンド
    - `bg`, `fg`コマンドで変更可能
### システムの状況把握
- `free`：メモリの使用状況
- `uptime`：システムの稼働時間や平均負荷（実行可能状態にアルプロセスと、ディスクの入出力の完了を待っている待機状態（割り込み不可）にあるプロセスの平均数）
### 端末の活用
- ...

## プロセスの実行優先度
- `ps -l`の出力のPRI列で優先度を確認できる

### コマンド実行時の優先度指定
- ナイス値：プロセスの実行優先度を管理する値
    - -20~19(負の値を設定できるのはrootユーザのみ)
    - 値が小さいほど優先度が高い
- Ex. 実行優先度を10高めてupdatedbコマンドを実行する
    - `# nice -n -10 updatedb`

### 実行中プロセスの優先度変更
- `renice`
- PIDを指定して特定のプロセスを変更する
- ユーザを指定して、そのユーザの実行しているプロセスに対して変更する
