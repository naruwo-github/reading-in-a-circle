# デバイスとLinuxファイルシステム
## パーティションとファイルシステムの作成
- ファイルシステム：ディスクに保存されるデータをファイルとして管理する仕組み
- ハードディスクやSSDを利用するには、ディスク内にパーティションを作り、パーティション内にファイルシステムを作り、そのファイルシステムをマウントするという作業を行う。
### ハードディスク
- 接続形態には規格がある。
    - SATA
    - SAS
    - SCSI
    - USB
- デバイスファイル：OSの入出力機能の一つで、コンピュータに接続した周辺機器などをファイルシステム上のファイルのように扱い、ファイルの読み書きと同じ手順でデータの入出力や制御をできるようにしたもの
    - 例えば、ハードディスクやSSD、DVDドライブ、シリアルポートといったデバイスの入出力を扱うための特殊なファイル
    - ファイルと同じ要領でデバイスにアクセスできる
        - デバイスへの出力＝デバイスファイルへの書き込み
        - デバイスからの入力＝デバイスファイルの読み込み
- Linuxが扱うデバイスには、ブロックデバイスとキャラクタデバイスがある
    - ブロックデバイス：ハードディスク(やパーティション)やSSDなど、メディア上の任意の場所にアクセスできるデバイスのこと
        - `lsblk`コマンド：システムのブロックデバイス一覧を表示する
    - キャラクタデバイス：キーボードやシリアルポートなど、文字単位でデータを読み書きするデバイスのこと

主なデバイスファイル
| ファイル名 | 説明 |
| --- | --- |
| /dev/sda | 1番目のハードディスク |
| /dev/sdb | 2番目のハードディスク |
| /dev/sdc | 3番目のハードディスク |
| /dev/sdd | 4番目のハードディスク |
| /dev/sr0 | 1番目のCD/DVDドライブ |
| /dev/st0 | 1番目のテープドライブ |

### パーティションの種類
- 1台のディスクドライブを複数の論理的な区画（パーティション）に分割して使うことができ、各パーティションには異なるファイルシステムを作成できる
- 基本パーティション
    - ディスク内に最大四つ作成できる
    - 内部にはファイルシステムを格納する
    - デバイスファイル名は、ハードディスク`/dev/sda`の場合、`/dev/sda1 ~ sda4`となる
- 拡張パーティション
    - 内部にはファイルシステムではなく論理パーティションを格納する
    - 基本パーティションの一つを拡張パーティションにすることができる
    - ※UEFIベースのシステムでは使われない
- 論理パーティション（拡張パーティション内に作成されたパーティションのこと）
    - デバイスファイル名は、`/dev/sda5`以降になる
    - ※UEFIベースのシステムでは使われない
- パーティション分割するメリット
    - システム障害によるファイルシステムの部分的な破壊の影響を一つのパーティション内に抑えることができる
    - 大量のログが発生してディスクの空き容量が足りなくなった場合も、被害をパーティション内に限定でき、他パーティションを使用するシステムに影響を与えなくてすむ
### ルートファイルシステム
- Linuxのディレクトリは木構造で、その頂点が`/`
- ルートファイルシステム：`/`ディレクトリを含むファイルシステム
    - 直下に`/home`や`/var`ディレクトリを配置する
        - 耐障害性や保守性を高めるために、ディスク上に複数のパーティションを用意して各パーティションに`/home`や`/var`を割り当てる
    - `/home`や`/var`は`/`以下にマウントされ、１つのファイルシステムとして運用できる
- マウント：ファイルシステム内のディレクトリツリーを、特定のディレクトリ以下に結合すること

ルートファイルシステムに必要なディレクトリ
| ディレクトリ | 内容 |
| --- | --- |
| /bin, /sbin | システムに必要なコマンド、プログラム |
| /etc | 各種設定 |
| /lib | ライブラリ |
| /dev | デバイスファイル |

- 参考：[hier - ファイルシステムの説明](https://linuxjm.osdn.jp/html/LDP_man-pages/man7/hier.7.html)

### パーティション管理コマンド（※取扱注意
- `fdisk`：パーティションの作成、削除、変更、情報表示など
    - `-l`：デバイスのパーティションテーブルの状態を表示する
        - Ex. `# fdisk -l /dev/sda`
```terminal
ubuntu@lts:~$ sudo fdisk -l /dev/sda
Disk /dev/sda: 10 GiB, 10737418240 bytes, 20971520 sectors
Disk model: QEMU HARDDISK   
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: gpt
Disk identifier: 749D7C21-A688-49F2-B8BA-495B3A40591F

Device      Start      End  Sectors  Size Type
/dev/sda1  206848 20971486 20764639  9.9G Linux filesystem
/dev/sda15   2048   204800   202753   99M EFI System

Partition table entries are not in disk order.
```

- `gdisk`：GPT対応のパーティション操作をする（サブコマンドはfdiskと同じ）
    - GPT(GUIDパーティションテーブル)：パーティションテーブルの方式の一つで、最大128個までパーティションを作成できる
    - MBR(マスターブートレコード)：従来方式。扱えるハードディスク容量は2TBまでで、基本パーティションを4個作成できる
- `parted`：MBRもGPTにも対応したパーティション操作コマンド
    - fdisk, gdiskと同様に対話形式でも実行できるが、`-s`を使って一度に処理できる
- ※：fdisk, gdiskは書き込み完了後に初めてパーティションテーブルに反映されるが、partedコマンドでは即座に反映される

### ファイルシステムの作成
- ファイルを保存するには、パーティション作成後にファイルシステムを作成する必要がある
- ファイルシステム：ファイルとしてディスク上のデータを扱う仕組み
    - 「182945セクタと182946セクタのデータを取り出す」→「/dataディレクトリ下のsales.txtファイルを開く」
    - セクタ：ディスク上の区画
        - 通常、1セクタは512byteで、CD-ROMでは2048byteと媒体によってまちまち
- ファイルシステムではブロックという単位でデータを管理する
    - これにより、プログラムは、物理的な媒体の種類に関わらずブロック単位でデータを扱える（ブロックという単位が媒体の差異を吸収）
- Linuxのファイルシステムでは、①「ファイルの中身（データ）」と②「ファイルの属性や管理情報」は別々に保存されている
    - iノード(index node)：②を格納している管理領域
        - ファイルシステム作成時にあらかじめ用意されており、ファイルやディレクトリを作成するたびに１つずつ割り当てられていく
- (Linuxで扱える)ファイルシステムの種類
    - 多くのディストリビューションで採用されているのが、Linux用に開発された`ext4`
    - CentOS7/RHEL7で標準の`XFS`は、`IRIX`というUNIXのファイルシステムとして開発された
    - IBMが作った`JFS`は、元々は`AIX`というUNIXのファイルシステムである
    - `Btrfs`：ext2/3/4ファイルシステムの欠点を解消し、その他先進的な機能を取り入れたファイルシステム
        - ext4はジャーナリングファイルシステム、一方Btrfsはコピーオンライトファイルシステム
            - ジャーナリングファイルシステム：後述…
        - 複数のデバイスをまとめてファイルシステムを構築できる（いわゆるRAIDを標準サポートしている）
        - reference: [Btrfs vs Ext4 – Functionalities, Strengths, and Weaknesses](https://linuxopsys.com/topics/btrfs-vs-ext4)
- `mkfs`コマンド：パーティション上にファイルシステムを作成する
    - 内部で、作成するファイルシステムに対応したコマンドを呼び出す
    - Ex. ext4ファイルシステムを`/dev/sdb1`に作成
        - `# mkfs -t ext4 /dev/sdb1`
- `mke2fs`コマンド：ext2/3/4ファイルシステムを作成する
    - `-t`：2/3/4の指定
    - `-j`：ext3を指定
- 参考：ext2/3/4ファイルシステムを作成すると、デフォルトでは5%の領域がrootユーザ用に予約される
    - rootユーザのみが書き込める領域で、万が一ディスクの空きがなくなってもrootユーザが作業ができるように確保している
    - mke2fsやtune2fsといったコマンドで変更可能
    - reference：[Linux ext3 や ext4 の予約領域の変更](https://kt-hiro.hatenablog.com/entry/20140413/13973848160)
- Btrfs(B-tree file system)の作成
    - `mkfs.btrfs`コマンドを実行する
    - 主な特徴
        - ストレージプール：複数の物理ボリューム(パーティションやディスク)をまとめて一つの仮想的なボリュームを作成できる
        - マルチデバイスファイルシステム：複数の物理ボリュームにまたがってファイルシステムを作成できる
        - スナップショット（ある時点におけるファイルシステムの状態を記録したもの）を作成できる
            - サブボリューム（後述）単位で作成する
            - スナップショットにより、ファイルシステムをアンマウントすることなくバックアップできる
                - アンマウント：デバイス上のファイルシステムとLinuxのディレクトリ（マウントポイント）との結びつきを解除すること
        - ファイルシステムを分割したサブボリュームを利用できる
            - スナップショットやサブボリュームの利点
                - 参考：[Btrfsを13年使ったのでその経験の話](https://chienomi.org/articles/linux/202203-btrfs.html)
                - もしスナップショット上のあるファイルが他のサブボリューム上のファイルと同じ内容同じ実体のままであれば、実体はひとつとなる。しかし、もとのサブボリュームのファイルが書き換えられた場合、その瞬間に別のファイルになる。
                    - →ハードリンクを用いた差分バックアップをものすごく便利にしたような形になっている
                - バックアップしたい、あるいは必要に応じて巻き戻したい単位にサブボリュームを切ることで取り回しがとても良くなる
                - スナップショットを使うことで間違ってファイルを消してしまうようなヒューマンエラーに対してリカバリーが効く
                - 外側のボリュームから見るとサブボリュームはただのディレクトリに見え、そのディレクトリに対して書き込みを行っても問題ない

<img src="https://www.ibm.com/docs/ja/ST3FR7_8.2.1/com.ibm.storwize.v7000.821.doc/svc_mdiskgrp_21iipo.gif" alt="ストレージ・ブール" width="600px">

画像出典：[IBM ストレージ・プール](https://www.ibm.com/docs/ja/flashsystem-7x00/8.2.x?topic=overview-storage-pools)

- `mkswap`コマンド：パーティション上にスワップ領域を作成する
    - 通常、スワップ領域として、独立したパーティションを割り当てる
    - システムには最低一つのスワップ領域が必要

## ファイルシステムの管理
### ディスク利用状況の確認
- `df`コマンド：ファイルシステムの容量確認
    - `-h/-H`オプション：容量の単位をM（1,048,576/1,000,000）として表示
    - `df -i`：iノードの使用状況を確認
- ファイルシステムの空き領域がなくなったり、何らかの原因でファイルシステムが破壊された場合、速やかに原因を特定して復旧する必要がある
- ファイルシステムに書き込めなくなる原因
    - 空き容量が不足している
        - 解決策の例：不要なファイルを削除する、別パーティションに新しいファイルシステムを作成する
    - 使用できるiノードがない
        - iノード：ディスク上のファイルに関する情報（アクセス権、所有者など）が記録されている
            - 全てのファイルには対応するiノードがある
            - ファイルシステム作成時に設定され、後から追加、変更できない
            - 枯渇すると、新規ファイルの保存ができなくなる
                - ※注意：小さなサイズのファイルを大量に保存する場合
- NOTE：ファイル保存時に、ファイルの中身はデータブロックに、属性情報はiノードブロックに情報が書き込まれる（物理的な保存位置はバラバラ）
    - →どちらかの書き込みが失敗すると生合成が取れなくなる（整合性は`fsck`で確認できる）
- `du`コマンド：ファイルやディレクトリが占める容量を表示する
### ファイルシステムのチェック
- `fsck`コマンド：ディスクのチェック、破損の修復ができる
    - ファイルシステムをアンマウントしておくか、少なくとも読み取り専用でマウントしておくこと
    - 実体はファイルシステムごとに用意されたチェックプログラムのフロントエンド
    - Linux起動時に自動実行され、`/etc/fstab`でfsckの対象に指定しているファイルシステムをチェックする
```terminal
ubuntu@lts:~$ cat /etc/fstab
LABEL=cloudimg-rootfs	/	 ext4	discard,errors=remount-ro	0 1
LABEL=UEFI	/boot/efi	vfat	umask=0077	0 1
```

- `e2fsck`コマンド：ext2/3/4用のチェック・修復コマンド
- ファイルシステムの破損の原因
    - [ファイル破損・データ破壊の原因と対策](https://jisaku-pc.net/hddhukyuu/archives/585)
    - [Windows10でファイルシステムエラーが出る原因と修復方法](https://recoverit.wondershare.jp/windows-error/fix-file-system-error-in-windows-10.html#:~:text=%E3%81%BE%E3%81%A8%E3%82%81%E3%81%BE%E3%81%97%E3%81%9F%E3%80%82-,%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%82%A8%E3%83%A9%E3%83%BC%E3%81%AE%E7%A8%AE%E9%A1%9E,-%E3%82%A8%E3%83%A9%E3%83%BC%E3%81%AE%E5%8E%9F%E5%9B%A0)

※`df`, `du`コマンドの各オプションの理解、`fsck`, `e2fsck`コマンドの動作についての理解をすること

### ファイルシステムの管理
- `tune2fs`コマンド：ext2/3/4ファイルシステムのさまざまなパラメータを設定する
    - 対象のファイルシステムはアンマウントにする or 読み取り専用でマウントしておく
### XFS
- SGI社が自社のUNIXであるIRIXように開発した、堅固で高速なジャーナリングファイルシステム
    - ジャーナリングファイルシステム：ファイルシステムの操作をジャーナル（ログ）に記録する仕組みを持ったファイルシステム
        - ファイルシステムの整合性チェックを素早く行える→障害発生時のシステム再起動時間を短縮できる
    - RHEL7やCentOS7で標準
        - OSSなので他のディストリビューションでも使える
        - 最大ファイルシステムサイズが8EB

XFSファイルシステムの主な操作コマンド
| コマンド | 説明 |
| --- | --- |
| mkfs.xfs | 新規作成 |
| xfs_info | 情報を表示 |
| xfs_db | デバッグ(対話形式でコマンド実行できる) |
| xfs_check | チェック |
| xfs_admin | パラメータ変更 |
| xfs_fsr | デフラグ(パソコン内部のストレージを最適化する処理のこと。データの保存・削除を繰り返し行うことで発生するストレージの断片化を解消し、読み書き速度を向上する操作「デフラグメンテーション」) |
| xfs_repair | 修復 |

※XFSの主なコマンド操作を覚えておくこと

## ファイルシステムのマウントとアンマウント
### マウントの仕組み
- `マウント`：複数のファイルシステムを組み合わせ、全体として一つのファイルシステムとして扱えるようにすること
    - リムーバブルメディアやリモートファイルシステムにも使われる
    - `マウントポイント`：マウントしたファイルシステムが結合されるディレクトリ
        - Ex. /media以下や/mnt以下などにあるからのディレクトリ

<img src="https://tech.pjin.jp/wp-content/uploads/2022/03/b88786aa957a43c5ef78187487298d04.png" alt="mount" width="600px">

画像出典：https://tech.pjin.jp/

### /etc/fstab ファイル
- ファイルシステムの情報を記述するファイルで、マウントの際はこのファイルが参照される
    - →マウントする頻度の高いファイルシステムを記述しておく
- 書式：`<①デバイスファイル名/ラベル/UUID> <②マウントポイント> <③ファイルシステムの種類> <④マウントオプション> <⑤dumpフラグ> <⑥ブート時にfsckがチェックする順序>`
    - ①
        - ラベル：パーティションには分かりやすいラベルを付けれる
        - UUID(Universally Unique Identifier)：デバイスに一意に付けられるID
            - `blkid`コマンドで、デバイスファイルとUUIDの対応を確認できる
            - ①でUUIDを指定するメリット：下記のエラーを防げる
                - システムにデバイスを追加すると、システム起動時の認識順序が変わることがあり、同じデバイスに割り当てられるデバイスファイル名が異なってしまうことがある
                    - →システム起動時やデバイスへのアクセス時にエラーが発生することがある。
    - ④：複数のオプションは「,」で繋げる
    - ⑤：1にするとdumpコマンドのバックアップ対象になる
        - `dump`コマンド：
    - ⑥
        - 0はチェックされない。1,2...の順でチェックされる。
        - ルートファイルシステムは1である必要がある

※`/etc/fstab`の”正確な”書式、それぞれの項目の意味を理解しておこう

### マウントとアンマウント
- 

## ファイルの配置と検索
### FHS
- 
### ファイルの検索
- 

